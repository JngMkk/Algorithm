# 정렬 알고리즘

대부분은 Quick Sort가 더 빠르지만 데이터에 따라 편차가 큰 반면,
Merge Sort는 일정하게 $O(n \times logn)$의 안정적인 성능을 보이며, 무엇보다 안정 정렬(Stable Sort)라는 점에서 많이 선호되는 편임.

파이썬은 Tim Sort를 사용함. 파이썬을 위해 C로 구현한 알고리즘.
실제 데이터는 대부분 이미 정렬되어 있을 것으로 가정하고 실제 데이터에서 고성능을 낼 수 있도록 설계한 알고리즘.
Insertion Sort와 Merge Sort를 heuristic하게 적절히 조합해 사용하는 정렬 알고리즘임.

대부분의 경우 정렬이 필요할 때는 파이썬의 정렬 함수를 사용하는 편이 가장 빠름.
그 이유는 실제 데이터에 적합한 Tim Sort를 사용하면서도, 파이썬 내장 함수로서 CPython을 이용해 작성되었기 때문.

Tim Sort는 자바에서도 사용.
자바의 Array.sort()는 Merge Sort의 개선 버전을 사용해오고 있었는데, Tim Sort가 인기를 얻기 시작하면서 자바 진영에서 이를 포팅하기 시작함.
이후 Tim Sort는 여러 벤치마크 테스트에서 최대 25배까지 빠른 성능을 올리는 것으로 확인되어 자바 7이 출시될 때는 자바 컬렉션의 공식 정렬 알고리즘으로 적용됨.

Go에서는 Tim Sort가 Merge Sort를 기반으로 하기 때문에 적어도 $O(1 \over 2 \times n)$의 추가 메모리 공간이 필요하다는 공간 복잡도를 이유로 들어 도입을 거절하기도 함.



- 정렬 알고리즘별 시간 복잡도

  | 알고리즘       | 최선       | 평균       | 최악       | 메모리          | 안정 |
  | -------------- | ---------- | ---------- | ---------- | --------------- | ---- |
  | Bubble Sort    | Ω(n)       | Θ(n^2)     | O(n^2)     | O(1)            | o    |
  | Insertion Sort | Ω(n)       | Θ(n^2)     | O(n^2)     | O(1)            | o    |
  | Quick Sort     | Ω(n log n) | Θ(n log n) | O(n^2)     | O(log n)        | x    |
  | Merge Sort     | Ω(n log n) | Θ(n log n) | O(n log n) | O(n)            | o    |
  | Heap Sort      | Ω(n log n) | Θ(n log n) | O(n log n) | O(1)            | x    |
  | Tim Sort       | Ω(n)       | Θ(n log n) | O(n log n) | O(1/2n) -> O(n) | o    |
  
  
  시간 복잡도가 $O(n \times logn)$이라는 말은 실제 동작 시간은 $C \times n \times logn + \alpha$라는 의미.
  
  상대적으로 무시할 수 있는 부분인 $\alpha$를 제외하면 $C$라는 상수 값에 따라 실제 동작 시간에 큰 차이가 생김.
  
  이 상수 값에 큰 영향을 끼치는 요소로 알고리즘이 참조 지역성(Locality of reference) 원리를 얼마나 잘 만족하는가가 있음.
  
  
  
  참조 지역성 원리란, CPU가 미래에 원하는 데이터를 예측하여 속도가 빠른 장치인 캐시 메모리에 담아 놓는데, 이 때의 예측률을 높이기 위해 사용하는 원리임.
  
  최근에 참조한 메모리나 그 메모리와 인접한 메모리를 다시 참조할 확률이 높다는 이론을 기반으로 캐시 메모리에 담아놓는 것.
  
  메모리를 연속으로 읽는 작업은 캐시 메모리에서 읽어오기에 빠른 반면, 무작위로 읽는 작업은 메인 메모리에서 읽어오기에 속도의 차이가 있음.
  
  
  
  - Heap Sort
  
    Heap sort의 경우 대표적으로 참조 지역성이 좋지 않은 정렬임.
  
    한 위치에 있는 요소를 해당 요소의 인덱스 두 배 또는 절반인 요소와 반복적으로 비교하기에 캐시 메모리에서는 예측하기가 매우 어려움.
  
    그렇기에 C는 상대적으로 다른 두 정렬들보다 큰 값으로 정의됨.
  
  - Merge Sort
  
    Merge sort의 경우 인접한 덩어리를 병합하기에 참조 지역성의 원리를 어느 정도 잘 만족함.
  
    그러나 입력 배열 크기만큼의 메모리를 추가로 사용한다는 단점이 있음.
  
    항상 일정한 속도를 보이지만 $O(n \times logn)$이상 빠르게 처리할 수 없음.
  
  - Quick Sort
  
    pivot 주변에서 데이터의 위치 이동이 빈번하게 발생하기에 참조 지역성이 좋으며 메모리를 추가로 사용하지 않음.
  
    실제로도 C의 값은 다른 두 정렬들보다 작은 값으로 정의되어 있고 평균 시간 복잡도는 셋(merge, heap, quick) 중에 가장 빠름.
  
    그러나 pivot을 선정하는 방법에 따라 최악의 경우 $O(n^2)$이 될 수 있다는 단점이 있음.
  
  - Tim Sort
  
    다른 정렬 알고리즘이 최선일 때도 점근 하한 $\Omega(n \times logn)$에 머무르는 데 반해
  
    Tim Sort는 실제 데이터는 대부분 이미 정렬되어 있을 것이라 가정하고 최적화를 함.
  
    이론적으로 어떠한 정렬 알고리즘도 한 번 이상 비교하게 되면 $\Omega(n \times logn)$보다 빨라질 수 없음.
  
    하지만 Tim Sort는 이미 정렬되어 있는 경우 비교를 건너뛰기 때문에 $\Omega(n)$까지 가능함.
  
    
  
    Insertion Sort는 인접한 메모리와의 비교를 반복하기에 참조 지역성의 원리를 매우 잘 만족함.
  
    이에 따라 Insertion sort의 상수 C를 $C_i$라 하고, $O(n \times logn)$ 정렬 알고리즘 중 C 값이 가장 작은 Quick Sort의 상수 C를 $C_j$라 할 때,
  
    작은 n에 대하여 $C_i \times n^2 < C_j \times (n \tiems logn)$이 성립함. 즉 작은 n에 대하여 Insertion Sort가 더 빠르다는 것임.
  
    이를 이용해 전체를 작은 덩어리로 잘라 각각의 덩어리를 Insertion Sort로 정렬한 뒤 병합하면 좀 더 빠를 것이란 생각이 기본 아이디어.
  
    
  
    Tim Sort에서 사용하는 Insertion Sort는 Binary Insertion Sort임.
  
    삽입해야 할 위치를 찾을 때까지 비교하는 대신, 앞의 원소들은 모두 정렬되어 있다는 전제를 기반으로 이분 탐색을 진행하여 위치를 찾음.
  
    이분 탐색은 참조 지역성은 떨어지지만 $O(n)$번의 비교 대신 $O(logn)$번의 비교 하기에 작은 n에 대하여 좀 더 시간을 절약할 수 있음.
  
    삽입해야 할 위치를 빠르게 찾아도 삽입하는 과정은 $O(n)$이기에 전체의 시간 복잡도는 $O(n^2)$으로
  
    일반적인 Insertion sort와 동일하지만 그 위치에 삽입하고 나머지 원소를 시프트하는 연산은 빠르기 때문에 훨씬 효율적임.
  
    
  
    
  