def solution(n):
    """
    for문 안에서 나머지 연산을 하는 것과 최종적으로 나머지 연산을 하는 것이 시간 차이가 나는 이유

    1. 수의 크기 (오버플로 문제 발생)
        파이썬과 같은 언어에서 정수(integers)는 기본적으로 임의 정밀도(arbitrary-precision)를 지원.
        이는 정수가 메모리에서 차지할 수 있는 크기가 고정되어 있지 않고, 필요에 따라 동적으로 조정될 수 있다는 것을 의미.
        따라서 수의 크기가 커질수록 더 많은 메모리가 필요하며, 이는 덧셈 연산에 필요한 시간도 증가함.

    2. 캐리(carry) 처리
        큰 수를 더할 때, 여러 비트 간에 캐리가 발생할 수 있음.
        이 캐리를 각 비트마다 전달하고 조정하는 과정이 필요하며, 이 과정은 단순히 두 개의 작은 수를 더하는 것보다 시간이 더 걸릴 수 있음.

    3. 메모리 접근과 캐시 효율성
        매우 큰 수의 경우, 이 수들이 프로세서의 캐시에 완전히 들어가지 않을 수 있음.
        이 경우, 메인 메모리에서 데이터를 가져오는데 더 많은 시간이 소요됨.
        더 큰 수는 더 많은 메모리 접근을 필요로 하며, 이는 전체 연산 속도를 늦출 수 있음.

    4. 연산 최적화의 부재
        작은 수의 연산은 하드웨어 수준에서 매우 최적화되어 있을 수 있지만, 큰 수의 연산은 종종 이러한 최적화의 혜택을 받지 못할 수 있음.
    """
    _map = [0] * (n + 1)
    _map[1] = 1
    _map[2] = 2
    for i in range(3, n + 1):
        _map[i] = (_map[i - 1] + _map[i - 2]) % 1000000007
    return _map[n]


n = 4
print(solution(n))  # 5

n = 5
print(solution(n))  # 8
